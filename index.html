<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D物理パルクールゲーム (操作修正・決定版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            background-color: #111;
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 98vw;
            height: 98vh;
            border-radius: 10px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 10;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            width: 280px;
            z-index: 10;
        }
        .control-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .control-item label { white-space: nowrap; margin-right: 10px; }
        .control-item input[type="range"] { width: 120px; }
        #reset-button { width: 100%; padding: 8px; background-color: #4f46e5; color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color: 0.3s; }
        #reset-button:hover { background-color: #4338ca; }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 0, 0.8); color: black; padding: 20px; border-radius: 10px; font-size: 24px; font-weight: bold; display: none; text-align: center; z-index: 100; }
        #touch-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        #joystick-area { position: absolute; bottom: 30px; left: 30px; width: 150px; height: 150px; background-color: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: auto; }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); }
        #jump-button { position: absolute; bottom: 40px; right: 40px; width: 100px; height: 100px; background-color: rgba(255, 255, 255, 0.4); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; font-weight: bold; color: white; border: 3px solid rgba(255, 255, 255, 0.6); pointer-events: auto; user-select: none; }
        @media (min-width: 1024px) {
            #joystick-area { width: 180px; height: 180px; bottom: 40px; left: 40px; }
            #joystick-handle { width: 70px; height: 70px; }
            #jump-button { width: 120px; height: 120px; bottom: 50px; right: 50px; font-size: 24px; }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="info-panel">
        <h2 class="text-lg font-bold mb-2">操作方法</h2>
        <p><span class="font-bold">PC:</span> W,A,S,Dで移動, スペースでジャンプ, マウスで視点</p>
        <p><span class="font-bold">タブレット:</span> 左下のパッドで移動, 右下のボタンでジャンプ, 画面スワイプで視点</p>
        <p class="mt-2">ステージから落ちると最初からになります。</p>
    </div>
    <div id="controls-panel">
        <h2 class="text-lg font-bold mb-3 text-center">物理パラメータ調整</h2>
        <div class="control-item"> <label for="gravity">重力 (Y軸)</label> <input type="range" id="gravity" min="-30" max="0" value="-9.82" step="0.1"> <span id="gravity-value">-9.82</span> </div>
        <div class="control-item"> <label for="jump-force">ジャンプ力</label> <input type="range" id="jump-force" min="1" max="15" value="7" step="0.1"> <span id="jump-force-value">7.0</span> </div>
        <div class="control-item"> <label for="move-speed">移動速度</label> <input type="range" id="move-speed" min="1" max="15" value="5" step="0.1"> <span id="move-speed-value">5.0</span> </div>
        <div class="control-item"> <label for="restitution">反発係数</label> <input type="range" id="restitution" min="0" max="1.5" value="0.3" step="0.01"> <span id="restitution-value">0.30</span> </div>
        <div class="control-item"> <label for="friction">摩擦係数</label> <input type="range" id="friction" min="0" max="1" value="0.4" step="0.01"> <span id="friction-value">0.40</span> </div>
        <button id="reset-button" class="mt-4">プレイヤーをリセット</button>
    </div>
    <div id="message-box">GOAL!</div>
    <div id="touch-controls">
        <div id="joystick-area"><div id="joystick-handle"></div></div>
        <div id="jump-button">JUMP</div>
    </div>

    <script type="module">
        let scene, camera, renderer, world;
        let playerBody, playerMesh;
        let controls = {};
        const meshes = [], bodies = [];
        const timeStep = 1 / 60;
        let lastCallTime = performance.now();
        let moveSpeed = 5;
        let jumpForce = 7;
        let canJump = false;
        const playerRadius = 0.5;
        const startPosition = new CANNON.Vec3(0, 5, 15);
        let cameraTarget = new THREE.Vector3();
        let cameraDistance = 5;
        let cameraAzimuth = Math.PI, cameraElevation = Math.PI / 6;
        let isDragging = false;
        let lastPointerX = null, lastPointerY = null;
        const joystickArea = document.getElementById('joystick-area');
        const joystickHandle = document.getElementById('joystick-handle');
        const joystickVector = { x: 0, z: 0 };
        const joystickRadius = joystickArea.clientWidth / 2;
        const gameContainer = document.getElementById('game-container');

        function init() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, gameContainer.clientWidth / gameContainer.clientHeight, 0.1, 1000);
            scene.add(camera);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            createPlayer();
            createStage();
            setupEventListeners();
            initControls();
            animate();
        }

        function createPlayer() {
            const playerShape = new CANNON.Sphere(playerRadius);
            playerBody = new CANNON.Body({ mass: 5, position: startPosition.clone(), shape: playerShape });
            playerBody.linearDamping = 0.5;
            world.addBody(playerBody);
            playerBody.addEventListener("collide", (event) => {
                const contactNormal = new CANNON.Vec3();
                if(event.contact){
                    if(event.contact.bi.id === playerBody.id) { event.contact.ni.negate(contactNormal); }
                    else { contactNormal.copy(event.contact.ni); }
                    if(contactNormal.y > 0.5){ canJump = true; }
                }
            });
            const playerGeometry = new THREE.SphereGeometry(playerRadius, 32, 32);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500 });
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.castShadow = true;
            scene.add(playerMesh);
        }
        
        function createStage() {
            const stageLayout = [
                { type: 'box', size: [20, 1, 30], position: [0, -0.5, 0] },
                { type: 'box', size: [4, 1, 4], position: [-8, 0.5, 5] },
                { type: 'box', size: [4, 1, 4], position: [-15, 1.5, -2] },
                { type: 'cylinder', size: [1, 1, 2], position: [-10, 3, -10] },
                { type: 'box', size: [2, 1, 8], position: [0, 2.5, -12] },
                { type: 'box', size: [8, 1, 2], position: [8, 3.5, -8] },
                { type: 'box', size: [2, 1, 8], position: [15, 4.5, -2] },
                { type: 'box', size: [15, 1, 15], position: [5, 5.5, -20], color: 0x00ff00 },
            ];
            stageLayout.forEach(item => createPlatform(item.type, item.size, item.position, item.color));
        }
        
        function createPlatform(type, size, position, color = 0xaaaaaa) {
            let shape, geometry;
            if (type === 'box') {
                const [sx, sy, sz] = size;
                shape = new CANNON.Box(new CANNON.Vec3(sx * 0.5, sy * 0.5, sz * 0.5));
                geometry = new THREE.BoxGeometry(sx, sy, sz);
            } else if (type === 'cylinder') {
                const [radiusTop, radiusBottom, height] = size;
                shape = new CANNON.Cylinder(radiusTop, radiusBottom, height, 16);
                geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 32);
            }
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(shape);
            body.position.set(position[0], position[1], position[2]);
            world.addBody(body);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(body.position);
            mesh.quaternion.copy(body.quaternion);
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshes.push(mesh);
            bodies.push(body);
        }

        function setupEventListeners() {
            window.addEventListener('keydown', (e) => { controls[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { controls[e.key.toLowerCase()] = false; });
            const startDrag = (x, y) => { isDragging = true; lastPointerX = x; lastPointerY = y; };
            const drag = (x, y) => {
                if (!isDragging) return;
                const deltaX = x - lastPointerX, deltaY = y - lastPointerY;
                lastPointerX = x; lastPointerY = y;
                cameraAzimuth -= deltaX * 0.005;
                cameraElevation -= deltaY * 0.005;
                cameraElevation = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraElevation));
            };
            const endDrag = () => { isDragging = false; };
            renderer.domElement.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
            renderer.domElement.addEventListener('mousemove', (e) => drag(e.clientX, e.clientY));
            renderer.domElement.addEventListener('mouseup', endDrag);
            renderer.domElement.addEventListener('mouseleave', endDrag);
            renderer.domElement.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { e.preventDefault(); startDrag(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false });
            renderer.domElement.addEventListener('touchmove', (e) => { if (e.touches.length === 1) { e.preventDefault(); drag(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false });
            renderer.domElement.addEventListener('touchend', endDrag);
            joystickArea.addEventListener('touchstart', (e) => handleJoystick(e.touches[0]), { passive: false });
            joystickArea.addEventListener('touchmove', (e) => handleJoystick(e.touches[0]), { passive: false });
            joystickArea.addEventListener('touchend', resetJoystick);
            function handleJoystick(touch) {
                const rect = joystickArea.getBoundingClientRect();
                const x = touch.clientX - rect.left - joystickRadius;
                const y = touch.clientY - rect.top - joystickRadius;
                const distance = Math.min(joystickRadius, Math.hypot(x, y));
                const angle = Math.atan2(y, x);
                joystickHandle.style.transform = `translate(-50%, -50%) translate(${distance * Math.cos(angle)}px, ${distance * Math.sin(angle)}px)`;
                joystickVector.x = (distance / joystickRadius) * Math.cos(angle);
                joystickVector.z = (distance / joystickRadius) * Math.sin(angle);
            }
            function resetJoystick() {
                joystickHandle.style.transform = `translate(-50%, -50%)`;
                joystickVector.x = 0; joystickVector.z = 0;
            }
            const jumpButton = document.getElementById('jump-button');
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); controls[' '] = true; });
            jumpButton.addEventListener('touchend', (e) => { e.preventDefault(); controls[' '] = false; });
            window.addEventListener('resize', () => {
                renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
                camera.aspect = gameContainer.clientWidth / gameContainer.clientHeight;
                camera.updateProjectionMatrix();
            });
        }
        
        function initControls() {
            const gravitySlider = document.getElementById('gravity'), jumpForceSlider = document.getElementById('jump-force'), moveSpeedSlider = document.getElementById('move-speed'), restitutionSlider = document.getElementById('restitution'), frictionSlider = document.getElementById('friction');
            const gravityValue = document.getElementById('gravity-value'), jumpForceValue = document.getElementById('jump-force-value'), moveSpeedValue = document.getElementById('move-speed-value'), restitutionValue = document.getElementById('restitution-value'), frictionValue = document.getElementById('friction-value'), resetButton = document.getElementById('reset-button');
            gravitySlider.addEventListener('input', (e) => { world.gravity.y = parseFloat(e.target.value); gravityValue.textContent = parseFloat(e.target.value).toFixed(2); });
            jumpForceSlider.addEventListener('input', (e) => { jumpForce = parseFloat(e.target.value); jumpForceValue.textContent = parseFloat(e.target.value).toFixed(1); });
            moveSpeedSlider.addEventListener('input', (e) => { moveSpeed = parseFloat(e.target.value); moveSpeedValue.textContent = parseFloat(e.target.value).toFixed(1); });
            const playerMaterial = new CANNON.Material("playerMaterial");
            playerBody.material = playerMaterial;
            const groundMaterial = new CANNON.Material("groundMaterial");
            bodies.forEach(body => body.material = groundMaterial);
            const contactMaterial = new CANNON.ContactMaterial(groundMaterial, playerMaterial, { friction: 0.4, restitution: 0.3 });
            world.addContactMaterial(contactMaterial);
            restitutionSlider.addEventListener('input', (e) => { contactMaterial.restitution = parseFloat(e.target.value); restitutionValue.textContent = parseFloat(e.target.value).toFixed(2); });
            frictionSlider.addEventListener('input', (e) => { contactMaterial.friction = parseFloat(e.target.value); frictionValue.textContent = parseFloat(e.target.value).toFixed(2); });
            resetButton.addEventListener('click', resetPlayer);
        }

        function resetPlayer() {
            playerBody.position.copy(startPosition);
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);
        }

        // ★★★★★ 左右反転の根本原因を修正した最終版ロジック ★★★★★
        function updatePlayerMovement() {
            const velocity = playerBody.velocity;
            
            // Step 1: カメラの「前」ベクトルを取得
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            // Step 2: カメラの「右」ベクトルを計算 (★★ ここが最重要修正点 ★★)
            const right = new THREE.Vector3();
            // 正しい「右」ベクトルは、「前方」ベクトルとワールドの「上」ベクトルの外積で計算します。
            // (誤) right.crossVectors(new THREE.Vector3(0, 1, 0), forward) -> これは「左」を向く
            // (正) right.crossVectors(forward, new THREE.Vector3(0, 1, 0)) -> これが正しい「右」
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            // Step 3: 入力を取得
            let moveX = 0; // 左右
            let moveZ = 0; // 前後

            if (controls['w']) moveZ += 1;
            if (controls['s']) moveZ -= 1;
            if (controls['a']) moveX -= 1;
            if (controls['d']) moveX += 1;
            
            moveX += joystickVector.x;
            moveZ -= joystickVector.z; 

            // Step 4: 移動ベクトルを合成
            const moveDirection = new THREE.Vector3();
            // 前後移動 = 「前」ベクトル * 前後入力
            moveDirection.add(forward.clone().multiplyScalar(moveZ));
            // 左右移動 = 「右」ベクトル * 左右入力
            moveDirection.add(right.clone().multiplyScalar(moveX));

            // Step 5: 物理ボディに速度を適用
            if (moveDirection.length() > 0.1) {
                if (moveDirection.length() > 1.0) {
                     moveDirection.normalize();
                }
                moveDirection.multiplyScalar(moveSpeed);
                velocity.x = moveDirection.x;
                velocity.z = moveDirection.z;
            } else {
                velocity.x *= 0.9;
                velocity.z *= 0.9;
            }

            // ジャンプ処理 (変更なし)
            if (controls[' '] && canJump) {
                velocity.y = jumpForce;
                canJump = false;
            }
        }

        function updateCamera() {
            cameraTarget.copy(playerMesh.position);
            const x = cameraTarget.x + cameraDistance * Math.sin(cameraAzimuth) * Math.cos(cameraElevation);
            const y = cameraTarget.y + cameraDistance * Math.sin(cameraElevation);
            const z = cameraTarget.z + cameraDistance * Math.cos(cameraAzimuth) * Math.cos(cameraElevation);
            camera.position.set(x, y, z);
            camera.lookAt(cameraTarget);
        }
        
        function checkGameState() {
            if (playerBody.position.y < -10) { resetPlayer(); }
            const goalPosition = new CANNON.Vec3(5, 5.5, -20);
            const distanceToGoal = playerBody.position.distanceTo(goalPosition);
            if (distanceToGoal < 8 && playerBody.position.y > 4) {
                 const messageBox = document.getElementById('message-box');
                 if (messageBox.style.display !== 'block') {
                    messageBox.style.display = 'block';
                    setTimeout(() => { messageBox.style.display = 'none'; resetPlayer(); }, 3000);
                 }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = (now - lastCallTime) / 1000;
            lastCallTime = now;
            updatePlayerMovement();
            world.step(timeStep, dt);
            playerMesh.position.copy(playerBody.position);
            playerMesh.quaternion.copy(playerBody.quaternion);
            updateCamera();
            checkGameState();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

